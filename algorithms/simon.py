import numpy as np
from quantum_simulator.simulator import NQubitSimulator
from utils.constants import HN, CNOT
from collections import defaultdict


class SimonAlgorithm:
 """
    Класс для реализации алгоритма Саймона.
    Алгоритм Саймона используется для поиска скрытого периода s в функции f,
    такой, что f(x) = f(x ⊕ s). Алгоритм находит период s за O(n) вызовов оракула.
    """

 def __init__(self, simulator: NQubitSimulator, oracle):
  """
        Инициализация алгоритма Саймона с симулятором и оракулом.

        Аргументы:
        - simulator: экземпляр квантового симулятора для работы с кубитами.
        - oracle: унитарный оператор, реализующий оракула, кодирующего функцию f(x).
        """
  self.simulator = simulator  # симулятор квантовой системы
  self.oracle = oracle  # оракул, реализующий булеву функцию

 def run(self) -> list:
  """
        Запуск алгоритма Саймона для поиска периода.

        Алгоритм Саймона:
        1. Применить операторы Адамара ко всем кубитам (верхняя часть кубитов).
        2. Применить оракула к системе.
        3. Применить операторы Адамара ко всем верхним кубитам снова.
        4. Измерить верхние кубиты для получения строки y, которая ортогональна s.
        """
  self.simulator.reset()  # сброс симулятора, все кубиты возвращаются в состояние |0⟩

  # Подготовка оператора Адамара для первых N кубитов
  hadamard_step1_gate = HN(self.simulator.dimension // 2)

  # Применение оператора Адамара ко всем верхним кубитам
  for _ in range(self.simulator.dimension // 2):
   hadamard_step1_gate = np.kron(hadamard_step1_gate, np.eye(2))  # дополнение до нужной размерности

  # Шаг 2: применить оператор Адамара к первым кубитам
  self.simulator.apply_n_qubit_gate(hadamard_step1_gate)

  # Шаг 3: применить оракула к системе
  self.simulator.apply_n_qubit_gate(self.oracle)

  # Шаг 4: снова применить операторы Адамара к первым кубитам
  self.simulator.apply_n_qubit_gate(hadamard_step1_gate)

  # Шаг 5: измерить первые N кубитов, чтобы получить строку y
  measured = self.simulator.measure_multiple_qubits(list(range(self.simulator.dimension // 2)))

  # Возвращаем результат измерений, который будет использоваться для вычисления периода
  return measured

 @staticmethod
 def example_n2_s11() -> int:
  """
        Пример для случая N = 2 и скрытой строки s = '11'.

        Использует оракула для функции с периодом '11'. Алгоритм многократно запускается,
        и результат измерений сохраняется, чтобы вычислить вероятность получения y.
        """
  N = 2  # Размер строки s (N = 2 для s = '11')
  measured_y = set()  # множество для хранения уникальных измерений

  # Оракул для s = '11'
  oracle = CNOT(4, 0, 2) @ CNOT(4, 0, 3) @ CNOT(4, 1, 2) @ CNOT(4, 1, 3)

  ITER_COUNT = 1024  # количество итераций для сбора статистики
  m = defaultdict(int)  # словарь для хранения частот измеренных значений y

  for i in range(ITER_COUNT):
   # Инициализация квантового симулятора с 2N кубитами (N верхних и N вспомогательных)
   sim = NQubitSimulator(N * 2)
   # Запуск алгоритма Саймона
   simon_alg = SimonAlgorithm(sim, oracle)
   result = simon_alg.run()  # результат измерений

   if result == [0, 0]:  # Пропускаем нулевые измерения (для повышения информативности)
    continue

   # Добавление результата в множество и словарь для подсчета частот
   measured_y.add(''.join(map(str, result)))  # конвертируем список [1, 0] в строку '10'
   m[''.join(map(str, result))] += 1

  # Вывод уникальных измерений и их частоты
  print(measured_y)
  print(m)

  # Возвращаем количество раз, когда результат был '11' (это должно быть максимальное значение)
  return m['11']

 @staticmethod
 def example_n3_s100() -> int:
  """
        Пример для случая N = 3 и скрытой строки s = '100'.

        Использует оракула для функции с периодом '100'. Алгоритм многократно запускается,
        и результат измерений сохраняется, чтобы вычислить вероятность получения y.
        """
  N = 3  # Размер строки s
  measured_y = set()  # множество для хранения уникальных измерений

  # Оракул для s = '100'
  oracle = CNOT(6, 0, 3)

  ITER_COUNT = 1024  # количество итераций для сбора статистики
  m = defaultdict(int)  # словарь для хранения частот измеренных значений y

  for i in range(ITER_COUNT):
   # Инициализация квантового симулятора с 2N кубитами (N верхних и N вспомогательных)
   sim = NQubitSimulator(N * 2)
   # Запуск алгоритма Саймона
   simon_alg = SimonAlgorithm(sim, oracle)
   result = simon_alg.run()  # результат измерений

   if result == [0, 0]:  # Пропускаем нулевые измерения
    continue

   # Добавление результата в множество и словарь для подсчета частот
   measured_y.add(''.join(map(str, result)))  # конвертируем список [1, 0, 0] в строку '100'
   m[''.join(map(str, result))] += 1

  # Вывод уникальных измерений и их частоты
  print(measured_y)
  print(m)

  # Возвращаем количество раз, когда результат был '100' (это должно быть максимальное значение)
  return m['100']
